/*
 * Copyright (C) 2018 Amlogic Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define LOG_TAG "aml_channel_map"


#include <unistd.h>
#include "aml_channel_map.h"
#include "log.h"
#include "aml_audio_log.h"

struct ch_present {
    char ch_name[16];
    channel_id_t ch_id;
    int  present;
    int  order;
};

typedef struct channel_map_item {
    int src_order;
    int dst_order;
    float scale;
} channel_map_item_t;


typedef struct channel_order {
    channel_order_type_t order_type;
    int ch;
    int ch_layout;  /*not used*/
    int chmap_item_cnt;
    channel_map_item_t *ch_map_items;
} channel_order_t;

/*these table will be generated by config file*/
static  channel_map_item_t hdmi_pcm8ch_map[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {2, 3 , 1.0},
    {3, 2 , 1.0},
    {4, 4 , 1.0},
    {5, 5 , 1.0},
    {6, 6 , 1.0},
    {7, 7 , 1.0},
};

static  channel_map_item_t hdmi_pcm8ch_map_4ch[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {2, 3 , 1.0},
    {3, 2 , 1.0},
    {4, 0 , 0.25},
    {5, 1 , 0.25},
    {6, 0 , 0.25},
    {7, 1 , 0.25},
};

static  channel_map_item_t hdmi_pcm2ch_map_8ch[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {0, 3 , 0.5},
    {1, 3 , 0.5},
    {0, 2 , 0.5},
    {1, 2 , 0.5},
    {0, 4 , 1.0},
    {1, 5 , 1.0},
    {0, 6 , 1.0},
    {1, 7 , 1.0},
};

static  channel_map_item_t hdmi_pcm2ch_map_4ch[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {0, 2 , 1.0},
    {1, 3 , 1.0},
};

static  channel_map_item_t hdmi_dolby2ch_map[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
};

static  channel_map_item_t hdmi_dolby4ch_map[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {2, 2 , 1.0},
    {3, 3 , 1.0},
};

static  channel_map_item_t hdmi_dolby8ch_map[] = {
    {0, 0 , 1.0},
    {1, 1 , 1.0},
    {2, 2 , 1.0},
    {3, 3 , 1.0},
    {4, 4 , 1.0},
    {5, 5 , 1.0},
    {6, 6 , 1.0},
    {7, 7 , 1.0},
};


static struct channel_order hdmi_pcm8ch = {
    .order_type = CHANNEL_ORDER_HDMIPCM,
    .ch = 8,
    .ch_layout = 0,
    .chmap_item_cnt = 0,
    .ch_map_items = NULL,
};

static struct channel_order hdmi_pcm2ch = {
    .order_type = CHANNEL_ORDER_HDMIPCM,
    .ch = 2,
    .ch_layout = 0,
    .chmap_item_cnt = 0,
    .ch_map_items = NULL,

};

static struct channel_order dolby_2ch = {
    .order_type = CHANNEL_ORDER_DOLBY,
    .ch = 2,
    .ch_layout = 0,
    .chmap_item_cnt = 0,
    .ch_map_items = NULL,

};

/*currently 8ch is 5.1.2*/
static struct channel_order dolby_8ch = {
    .order_type = CHANNEL_ORDER_DOLBY,
    .ch = 8,
    .ch_layout = 0,
    .chmap_item_cnt = 0,
    .ch_map_items = NULL,

};

static struct channel_order dolby_4ch = {
    .order_type = CHANNEL_ORDER_DOLBY,
    .ch = 4,
    .ch_layout = 0,
    .chmap_item_cnt = 0,
    .ch_map_items = NULL,

};

#define CH_ORDER_NUM    10
static struct channel_order ch_orders[CH_ORDER_NUM] = {
};

/*the string is same with Dolby*/
static struct ch_present ch_presents[] = {
    {"lr",  CHANNEL_LEFT_FRONT, 0},
    {"lr",  CHANNEL_RIGHT_FRONT, 0},
    {"c",   CHANNEL_CENTER, 0},
    {"lfe", CHANNEL_LFE, 0},
    {"lrs", CHANNEL_LEFT_SURROUND, 0},
    {"lrs", CHANNEL_RIGHT_SURROUND, 0},
    {"lrtf", CHANNEL_LEFT_TOP_FRONT, 0},
    {"lrtf", CHANNEL_RIGHT_TOP_FRONT, 0},
    {"lrtm", CHANNEL_LEFT_TOP_MIDDLE, 0},
    {"lrtm", CHANNEL_RIGHT_TOP_MIDDLE, 0},
    {"lre",  CHANNEL_LEFT_DOLBY_ENABLE, 0},
    {"lre",  CHANNEL_RIGHT_DOLBY_ENABLE, 0},
};

static void set_channel_map_default(int ch)
{
    /*we need to replace these config with config file*/
    if (ch > 4) {
        hdmi_pcm8ch.chmap_item_cnt = sizeof(hdmi_pcm8ch_map) / sizeof(channel_map_item_t);
        hdmi_pcm8ch.ch_map_items = &hdmi_pcm8ch_map[0];
        ch_orders[0] = hdmi_pcm8ch;

        hdmi_pcm2ch.chmap_item_cnt = sizeof(hdmi_pcm2ch_map_8ch) / sizeof(channel_map_item_t);
        hdmi_pcm2ch.ch_map_items = &hdmi_pcm2ch_map_8ch[0];
        ch_orders[1] = hdmi_pcm2ch;


    } else {
        hdmi_pcm8ch.chmap_item_cnt = sizeof(hdmi_pcm8ch_map_4ch) / sizeof(channel_map_item_t);
        hdmi_pcm8ch.ch_map_items = &hdmi_pcm8ch_map_4ch[0];
        ch_orders[0] = hdmi_pcm8ch;

        hdmi_pcm2ch.chmap_item_cnt = sizeof(hdmi_pcm2ch_map_4ch) / sizeof(channel_map_item_t);
        hdmi_pcm2ch.ch_map_items = &hdmi_pcm2ch_map_4ch[0];
        ch_orders[1] = hdmi_pcm2ch;
    }


    dolby_2ch.chmap_item_cnt = sizeof(hdmi_dolby2ch_map) / sizeof(channel_map_item_t);
    dolby_2ch.ch_map_items = &hdmi_dolby2ch_map[0];
    ch_orders[2] = dolby_2ch;

    dolby_8ch.chmap_item_cnt = sizeof(hdmi_dolby8ch_map) / sizeof(channel_map_item_t);
    dolby_8ch.ch_map_items = &hdmi_dolby8ch_map[0];
    ch_orders[3] = dolby_8ch;

    dolby_4ch.chmap_item_cnt = sizeof(hdmi_dolby4ch_map) / sizeof(channel_map_item_t);
    dolby_4ch.ch_map_items = &hdmi_dolby4ch_map[0];
    ch_orders[4] = dolby_4ch;
}

static channel_order_t * get_channel_map(int ch, channel_order_type_t order_type)
{
    int i = 0;

    for (i = 0; i < CH_ORDER_NUM ; i++) {
        if (ch_orders[i].ch == ch && ch_orders[i].order_type == order_type) {
            return &ch_orders[i];
        }
    }
    return NULL;
}



static void init_ch_presents(char * speaker_config)
{
    char * token = NULL;
    int item = 0;
    int i = 0;
    int ch_cnt = 0;
    char temp[256] = {0};

    if (speaker_config == NULL) {
        return;
    }

    memcpy(temp, speaker_config, strlen(speaker_config));
    item = sizeof(ch_presents) / sizeof(struct ch_present);
    token = strtok(temp, ":");

    for (i = 0; i < item; i++) {
        ch_presents[i].present = 0;
        ch_presents[i].order   = -1;
    }
    /*if there is no config, set all the presents on*/
    if (token == NULL) {
        for (i = 0; i < item; i++) {
            ch_presents[i].present = 1;
        }
    }
    while (token != NULL) {

        for (i = 0; i < item; i++) {
            if (!strcmp(ch_presents[i].ch_name, token)) {
                ch_presents[i].present = 1;
                ch_presents[i].order   = ch_cnt;
                ch_cnt++;
                ALOGD(" channel presents=%s id=%d order=%d\n", ch_presents[i].ch_name, ch_presents[i].ch_id, ch_presents[i].order);
            }
        }
        token = strtok(NULL, ":");

    }
    return;
}

static inline int get_speaker_ch_cnt(void)
{
    int item = 0;
    int i = 0;
    int ch_cnt = 0;
    item = sizeof(ch_presents) / sizeof(struct ch_present);

    for (i = 0; i < item; i++) {
        if (ch_presents[i].present) {
            ch_cnt++;
        }
    }
    return ch_cnt;
}

int aml_channelinfo_init(channel_info_t * channel_info)
{
    int i = 0, j = 0;
    int item = 0;
    item = sizeof(ch_presents) / sizeof(struct ch_present);
    for (i = 0; i < AML_MAX_CHANNELS; i++) {
        channel_info->channel_items[i].ch_id = -1;
        channel_info->channel_items[i].present = 0;
        channel_info->channel_items[i].order = -1;

        for (j = 0; j < item; j++) {
            if (i == ch_presents[j].order) {
                channel_info->channel_items[i].ch_id   = ch_presents[j].ch_id;
                channel_info->channel_items[i].present = ch_presents[j].present;
                channel_info->channel_items[i].order   = ch_presents[j].order;
            }
        }
    }
    return 0;
}

void aml_channelmap_dumpinfo(void * private)
{
    aml_channel_map_t * handle = (aml_channel_map_t *)private;
    channel_order_t *channel_order = NULL;
    int ch_map_cnt = 0;
    int src_order = 0;
    int dst_order = 0;
    float sacling = 1.0;
    int i = 0;

    channel_order = (channel_order_t *)handle->map_info;
    if (channel_order) {
        ch_map_cnt = channel_order->chmap_item_cnt;
        ALOGA("order type=%d ch=%d\n", channel_order->order_type, channel_order->ch);
        for (i = 0; i < ch_map_cnt; i++) {
            ALOGA("map (%d)->%d scale=%f\n", channel_order->ch_map_items[i].src_order, channel_order->ch_map_items[i].dst_order, channel_order->ch_map_items[i].scale);
        }
    }

    return;
}



int aml_channelmap_init(aml_channel_map_t ** handle, int ch, char * speaker_config)
{
    int ret = -1;
    int i = 0;
    int size = 1024 * 4;
    void *tmp_map_buffer;
    aml_channel_map_t * channel_map = NULL;
    aml_data_format_t * format = NULL;

    ALOGD("MAP INIT\n");

    channel_map = calloc(1 , sizeof(aml_channel_map_t));

    if (channel_map == NULL) {
        ALOGD("channel_map malloc failed\n");
        goto exit;
    }

    tmp_map_buffer = calloc(1 , size);
    if (tmp_map_buffer == NULL) {
        ALOGD("tmp_map_buffer malloc failed\n");
        goto exit;

    }

    channel_map->map_buffer = tmp_map_buffer;
    channel_map->map_buffer_size = size;

    format = &channel_map->format;

    format->ch = ch;

    /*get the speaker config */
    init_ch_presents(speaker_config);

    /*this speaker ch is different with the input ch*/
    set_channel_map_default(get_speaker_ch_cnt());

    /*according the speaker config to set the channel info*/
    aml_channelinfo_init(&channel_map->format.channel_info);


    *handle = channel_map;

    aml_log_dumpinfo_install(LOG_TAG, aml_channelmap_dumpinfo, channel_map);

    return 0;
exit:
    if (channel_map) {
        free(channel_map);
    }
    if (tmp_map_buffer) {
        free(tmp_map_buffer);
    }
    return -1;

}

int aml_channelmap_close(aml_channel_map_t * handle)
{
    if (handle == NULL) {
        return 0;
    }

    aml_log_dumpinfo_remove(LOG_TAG);

    if (handle->map_buffer) {
        free(handle->map_buffer);
        handle->map_buffer = NULL;
    }

    free(handle);

    return 0;
}

int aml_channelmap_process(aml_channel_map_t * handle, aml_data_format_t *src, void * in_data, size_t nframes)
{
    int i = 0, j = 0;
    int dst_channels = 0;
    int src_channels = 0;
    aml_data_format_t * dst = NULL;
    channel_order_t *channel_order = NULL;
    int ch_map_cnt = 0;
    int src_order = 0;
    int dst_order = 0;
    float sacling = 1.0;

    size_t need_bytes = 0;
    dst = &handle->format;
    dst->bitwidth = src->bitwidth;
    dst->format   = src->format;
    dst->sr       = src->sr;
    dst->ch_order_type = src->ch_order_type;

    need_bytes = nframes * (dst->bitwidth >> 3) * dst->ch;

    if (handle->map_buffer_size < need_bytes) {
        ALOGI("realloc map_buffer_size  from %zu to %zu\n", handle->map_buffer_size, need_bytes);
        handle->map_buffer = realloc(handle->map_buffer, need_bytes);
        if (handle->map_buffer == NULL) {
            ALOGE("realloc map_buffer failed size %zu\n", need_bytes);
            return -1;
        }
        handle->map_buffer_size = need_bytes;
        memset(handle->map_buffer, 0, need_bytes);

    }
    memset(handle->map_buffer, 0, need_bytes);
    handle->out_buffer_size = need_bytes;


    channel_order = get_channel_map(src->ch, src->ch_order_type);
    if (channel_order == NULL) {
        ALOGE("There is no Mapping for ch=%d type=%d\n", src->ch, src->ch_order_type);
        return 0;
    }

    handle->map_info = (void*)channel_order;

    ch_map_cnt = channel_order->chmap_item_cnt;
    //ALOGD("channel map cnt=%d src ch=%d type=%d\n",ch_map_cnt,src->ch, src->ch_order_type);
    for (i = 0; i < ch_map_cnt; i++) {
        switch (src->bitwidth) {
        case SAMPLE_8BITS:
            // not support
            break;
        case SAMPLE_16BITS: {
            short * src_data = (short *)in_data;
            short * dst_data = (short *)handle->map_buffer;
            int src_channel  = src->ch;
            int dst_channel  = dst->ch;
            dst_order = channel_order->ch_map_items[i].dst_order;
            src_order = channel_order->ch_map_items[i].src_order;
            sacling   = channel_order->ch_map_items[i].scale;
            for (j = 0; j < nframes; j ++) {
                dst_data[j * dst_channel + dst_order] += src_data[j * src_channel + src_order] * sacling;

            }
        }
        break;
        case SAMPLE_24BITS:
            // not suppport
            break;
        case SAMPLE_32BITS: {
            int * src_data = (int *)in_data;
            int * dst_data = (int *)handle->map_buffer;
            int src_channel  = src->ch;
            int dst_channel  = dst->ch;
            dst_order = channel_order->ch_map_items[i].dst_order;
            src_order = channel_order->ch_map_items[i].src_order;
            sacling   = channel_order->ch_map_items[i].scale;
            for (j = 0; j < nframes; j ++) {
                dst_data[j * dst_channel + dst_order] += src_data[j * src_channel + src_order] * sacling;

            }
        }
        break;
        default:
            break;
        }
    }

    memcpy(&src->channel_info, &dst->channel_info, sizeof(channel_info_t));
    //ALOGE("exit\n");
    return 0 ;
}
